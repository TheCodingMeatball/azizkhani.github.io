---
layout: post
title: "JAVA INTERVIEW QUESTIONS PAGE :D"
comments: true
---
<p><strong>1. What is the difference between private, protected, and public?<br /> </strong><br /> These keywords are for allowing privileges to components such as java methods and variables.<br /> Public: accessible to all classes<br /> Private: accessible only to the class to which they belong<br /> Protected: accessible to the class to which they belong and any subclasses.<br /> Access specifiers are keywords that determines the type of access to the member of a class. These are:<br /> * Public<br /> * Protected<br /> * Private<br /> * Defaults<br /><br /> <strong>2. What's the difference between an interface and an abstract class? Also discuss the similarities. <span style="color: #ff0000;">(Very Important)<br /> </span></strong><br /> Abstract class is a class which contain one or more abstract methods, which has to be implemented by sub classes. Interface is a Java Object containing method declaration and doesn't contain implementation. The classes which have implementing the Interfaces must provide the method definition for all the methods<br /> Abstract class is a Class prefix with a abstract keyword followed by Class definition. Interface is a Interface which starts with interface keyword.<br /> Abstract class contains one or more abstract methods. where as Interface contains all abstract methods and final declarations<br /> Abstract classes are useful in a situation that Some general methods should be implemented and specialization behavior should be implemented by child classes. Interfaces are useful in a situation that all properties should be implemented.<br /><br /> <em>Differences are as follows:</em><br /><br /> * Interfaces provide a form of multiple inheritance. A class can extend only one other class.<br /> * Interfaces are limited to public methods and constants with no implementation. Abstract classes can have a partial implementation, protected parts, static methods, etc.<br /> * A Class may implement several interfaces. But in case of abstract class, a class may extend only one abstract class.<br /> * Interfaces are slow as it requires extra indirection to to find corresponding method in in the actual class. Abstract classes are fast.&nbsp;<br /><br /> <em>Similarities:</em><br /><br /> * Neither Abstract classes or Interface can be instantiated.<br /><br /> <em>How to define an Abstract class?</em><br /> A class containing abstract method is called Abstract class. An Abstract class can't be instantiated.<br /> <span style="text-decoration: underline;">Example of Abstract class:</span><br /><br /> abstract class testAbstractClass {&nbsp;<br /> &nbsp;&nbsp;&nbsp; protected String myString;&nbsp;<br /> &nbsp;&nbsp;&nbsp; public String getMyString() {&nbsp;<br /> &nbsp;&nbsp;&nbsp; return myString;&nbsp;<br /> }&nbsp;<br /> public abstract string anyAbstractFunction();<br /> }<br /> <br /> <em>How to define an Interface?<br /> </em>Answer: In Java Interface defines the methods but does not implement them. Interface can include constants. A class that implements the interfaces is bound to implement all the methods defined in Interface.<br /> <span style="text-decoration: underline;">Example of Interface:</span><br /> <br /> public interface sampleInterface {<br /> &nbsp;&nbsp;&nbsp; public void functionOne();<br /> &nbsp;&nbsp;&nbsp; public long CONSTANT_ONE = 1000;<br /> }<br /><br /> <strong>3. Question: How you can force the garbage collection?<br /> <br /> </strong>Garbage collection automatic process and can't be forced. You could request it by calling System.gc(). JVM does not guarantee that GC will be started immediately.<br /><br /> <em>Garbage collection</em> is one of the most important feature of Java, Garbage collection is also called automatic memory management as <a href="http://www.freejavaguide.com/virtual_machine.html">JVM</a> automatically removes the unused variables/objects (value is null) from the memory. User program can't directly free the object from memory, instead it is the job of the garbage collector to automatically free the objects that are no longer referenced by a program. Every class inherits finalize() method from java.lang.Object, the finalize() method is called by garbage collector when it determines no more references to the object exists. In Java, it is good idea to explicitly assign null into a variable when no more in use. I Java on calling System.gc() and Runtime.gc(), JVM tries to recycle the unused objects, but there is no guarantee when all the objects will garbage collected.<br /><br /> <strong>4. What's the difference between constructors and normal methods?<br /> </strong><br /> Constructors must have the same name as the class and can not return a value. They are only called once while regular methods could be called many times and it can return a value or can be void.<br /><br /> <strong>5. Can you call one constructor from another if a class has multiple constructors<br /> </strong><br /> Yes. Use this() to call a constructor from an other constructor.<br /><br /> <strong>6. Explain the usage of Java packages.<br /> </strong><br /> This is a way to organize files when a project consists of multiple modules. It also helps resolve naming conflicts when different packages have classes with the same names. Packages access level also allows you to protect data from being used by the non-authorized classes.<br /><br /> <strong>7. Explain in your own words the "bottom line" benefits of the use of an interface.</strong><br /><br /> The interface makes it possible for a method in one class to invoke methods on objects of other classes, without the requirement to know the true class of those objects, provided that those objects are all instantiated from classes that implement one or more specified interfaces. In other words, objects of classes that implement specified interfaces can be passed into methods of other objects as the generic type Object, and the methods of the other objects can invoke methods on the incoming objects by first casting them as the interface type.<br /><br /> <strong>8. What are some advantages and disadvantages of Java Sockets?<br /> <br /> </strong><em>Some advantages of Java Sockets:&nbsp;</em><br /> Sockets are flexible and sufficient. Efficient socket based programming can be easily implemented for general communications. Sockets cause low network traffic. Unlike HTML forms and CGI scripts that generate and transfer whole web pages for each new request, <a href="http://www.freejavaguide.com/java_applet.html">Java applets</a> can send only necessary updated information.<br /><br /> <em>Some disadvantages of Java Sockets:</em><br /> Security restrictions are sometimes overbearing because a Java applet running in a Web browser is only able to establish connections to the machine where it came from, and to nowhere else on the network&nbsp;&nbsp; Despite all of the useful and helpful Java features, Socket based communications allows only to send packets of raw data between applications. Both the client-side and server-side have to provide mechanisms to make the data useful in any way.<br /><br /> <strong>9. Explain the usage of the keyword transient?<br /> </strong><br /> Transient keyword indicates that the value of this member variable does not have to be serialized with the object. When the class will be de-serialized, this variable will be initialized with a default value of its data type (i.e. zero for integers).<br /><br /> <strong>10. What's the difference between the methods sleep() and wait()<br /> <br /> </strong>The code sleep(1000); puts thread aside for exactly one second. The code wait(1000), causes a wait of up to one second. A thread could stop waiting earlier if it receives the notify() or notifyAll() call. The method wait() is defined in the class Object and the method sleep() is defined in the class Thread.<br /><br /> <strong>11. What would you use to compare two String variables - the operator == or the method equals()?<br /> <br /> </strong>I'd use the method equals() to compare the values of the Strings and the == to check if two variables point at the same instance of a String object.<br /> <br /> <strong>12. Why would you use a synchronized block vs. synchronized method?</strong><br /> <br /> Synchronized blocks place locks for shorter periods than synchronized methods.<br /><br /> <strong>13. What access level do you need to specify in the class declaration to ensure that only classes from the same directory can access it?<br /> </strong><br /> You do not need to specify any access level, and Java will use a default package access level.<br /><br /> <strong>14. Can an inner class declared inside of a method access local variables of this method?<br /> <br /> </strong>It's possible if these variables are final.<br /><br /> <strong>15. What can go wrong if you replace &amp;&amp; with &amp; in the following code:</strong><br /> <strong>String a=null; if (a!=null &amp;&amp; a.length()&gt;10) {...}<br /> </strong><br /> A single ampersand here would lead to a NullPointerException.<br /> <br /> <strong>16. What's the main difference between a Vector and an ArrayList?</strong><br /> <br /> Java Vector class is internally synchronized and ArrayList is not synchronized.<br /><br /> <strong>17. Describe the wrapper classes in Java.<br /> <br /> </strong>Wrapper class is wrapper around a primitive data type. An instance of a wrapper class contains, or wraps, a primitive value of the corresponding type.<br /><br /> Following table lists the primitive types and the corresponding wrapper classes:<br /> Primitive Wrapper<br /> boolean&nbsp; - java.lang.Boolean<br /> byte - java.lang.Byte<br /> char - java.lang.Character<br /> double - java.lang.Double<br /> float - java.lang.Float<br /> int - java.lang.Integer<br /> long - java.lang.Long<br /> short - java.lang.Short<br /> void - java.lang.Void<br /><br /> <strong>18. How could Java classes direct program messages to the system console, but error messages, say to a file?<br /> </strong><br /> The class System has a variable out that represents the standard output, and the variable err that represents the standard error device. By default, they both point at the system console. This how the standard output could be re-directed:<br /> Stream st = new Stream(new FileOutputStream("output.txt")); System.setErr(st); System.setOut(st);<br /><br /> <strong>19. How do you know if an explicit object casting is needed?<br /> </strong><br /> If you assign a superclass object to a variable of a subclass's data type, you need to do explicit casting. For example:<br /> Object a; Customer b; b = (Customer) a;<br /><br /> <strong>20. When you assign a subclass to a variable having a supeclass type, the casting is performed automatically. Can you write a Java class that could be used both as an applet as well as an application?<br /> </strong><br /> Yes. Add a main() method to the applet.<br /><br /> <strong>21. If a class is located in a package, what do you need to change in the OS environment to be able to use it?<br /> </strong><br /> You need to add a directory or a jar file that contains the package directories to the CLASSPATH environment variable. Let's say a class Employee belongs to a package com.xyz.hr; and is located in the file c:\dev\com\xyz\hr\Employee.javIn this case, you'd need to add c:\dev to the variable CLASSPATH. If this class contains the method main(), you could test it from a command prompt window as follows:<br /> c:\&gt;java com.xyz.hr.Employee<br /><br /> <strong>22. What's the difference between J2SDK 1.5 and J2SDK 5.0?<br /> <br /> </strong>There's no difference, Sun Microsystems just re-branded this version.<br /> <br /> <strong>23. Does it matter in what order catch statements for FileNotFoundException and IOExceptipon are written?</strong><br /><br /> Yes, it does. The FileNoFoundException is inherited from the IOException. Exception's subclasses have to be caught first.<br /><br /> <strong>24. Name the containers which uses Border Layout as their default layout?<br /> </strong><br /> Containers which uses Border Layout as their default are: window, Frame and Dialog classes.<br /><br /> <strong>25. You are planning to do an indexed search in a list of objects. Which of the two Java collections should you use:<br /> ArrayList or LinkedList?<br /> </strong><br /> ArrayList<br /><br /> <strong>26. When should the method invokeLater()be used?<br /> </strong><br /> This method is used to ensure that Swing components are updated through the event-dispatching thread.<br /> <br /> <strong>27. How can a subclass call a method or a constructor defined in a superclass?</strong><br /><br /> Use the following syntax: super.myMethod(); To call a constructor of the superclass, just write super(); in the first line of the subclass's constructor.<br /><br /> <strong>28. What do you understand by Synchronization?<br /> </strong><br /> Synchronization is a process of controlling the access of shared resources by the multiple threads in such a manner that only one thread can access one resource at a time. In non synchronized multithreaded application, it is possible for one thread to modify a shared object while another thread is in the process of using or updating the object's value. Synchronization prevents such type of data corruption.<br /> E.g. Synchronizing a function:<br /> public synchronized void Method1 () {<br /> &nbsp;&nbsp;&nbsp; // Appropriate method-related code.&nbsp;<br /> }<br /> E.g. Synchronizing a block of code inside a function:<br /> public myFunction (){<br /> &nbsp;&nbsp;&nbsp; synchronized (this) {&nbsp;<br /> &nbsp;&nbsp;&nbsp; // Synchronized code here.<br /> &nbsp; }<br /> }<br /><br /> <strong>29. What's the difference between a queue and a stack?<br /> </strong><br /> Stacks works by last-in-first-out rule (LIFO), while queues use the FIFO rule<br /><br /> <strong>30. You can create an abstract class that contains only abstract methods. On the other hand, you can create an interface that declares the same methods. So can you use abstract classes instead of interfaces?<br /> </strong><br /> Sometimes. But your class may be a descendent of another class and in this case the interface is your only option.<br /> <br /> <strong>31. If you're overriding the method equals() of an object, which other method you might also consider?</strong><br /> <br /> hashCode()<br /><br /> <strong>32. What is Collection API?<br /> </strong><br /> The Collection API is a set of classes and interfaces that support operation on collections of objects. These classes and interfaces are more flexible, more powerful, and more regular than the vectors, arrays, and hashtables if effectively replaces.&nbsp;<br /> Example of classes: HashSet, HashMap, ArrayList, LinkedList, TreeSet and TreeMap.<br /> Example of interfaces: Collection, Set, List and Map.<br /><br /> <strong>33. How would you make a copy of an entire Java object with its state?<br /> </strong><br /> Have this class implement Cloneable interface and call its method clone().<br /><br /> <strong>34. How can you minimize the need of garbage collection and make the memory use more effective?<br /> </strong><br /> Use object pooling and weak object references.<br /> <br /> <strong>35. There are two classes: A and B. The class B need to inform a class A when some important event has happened. What Java technique would you use to implement it?</strong><br /> <br /> If these classes are threads I'd consider notify() or notifyAll(). For regular classes you can use the Observer interface.<br /><br /> <strong>36. Explain the Encapsulation principle.<br /> <br /> </strong>Encapsulation is a process of binding or wrapping the data and the codes that operates on the data into a single entity. This keeps the data safe from outside interface and misuse. One way to think about encapsulation is as a protective wrapper that prevents code and data from being arbitrarily accessed by other code defined outside the wrapper.&nbsp;<br /><br /> <strong>37. Explain the Inheritance principle.<br /> <br /> </strong>Inheritance is the process by which one object acquires the properties of another object.&nbsp;<br /><br /> <strong>38. Explain the Polymorphism principle.<br /> <br /> </strong>The meaning of Polymorphism is something like one name many forms. Polymorphism enables one entity to be used as as general category for different types of actions. The specific action is determined by the exact nature of the situation. The concept of polymorphism can be explained as "one interface, multiple methods".&nbsp;<br /> <span style="text-decoration: underline;">From a practical programming viewpoint, polymorphism exists in three distinct forms in Java:<br /> </span><br /> * Method overloading<br /> * Method overriding through inheritance<br /> * Method overriding through the Java interface<br /><br /> <strong>39. Is Iterator a Class or Interface? What is its use?<br /> </strong><br /> Iterator is an interface which is used to step through the elements of a Collection.&nbsp;<br /><br /> <strong>40. Explain the user defined Exceptions?<br /> </strong><br /> User defined Exceptions are the separate Exception classes defined by the user for specific purposed. An user defined can created by simply sub-classing it to the Exception class. This allows custom exceptions to be generated (using throw) and caught in the same way as normal exceptions.<br /> <span style="text-decoration: underline;">Example:</span><br /><br /> class myCustomException extends Exception {<br /> &nbsp;&nbsp;&nbsp;&nbsp; / The class simply has to exist to be an exception<br /> }<br /> <br /><br /> <strong>41. What is OOPS?</strong><br /><br /> OOP is the common abbreviation for <a href="http://www.freejavaguide.com/object_oriented_programming.html">Object-Oriented Programming</a>.&nbsp;<br /> There are three main principals of oops which are called Polymorphism, Inheritance and Encapsulation.&nbsp;<br /><br /> <strong>39.&nbsp; Read the following program:</strong><br /><br /> public class test {<br /> public static void main(String [] args) {<br /> &nbsp;&nbsp;&nbsp; int x = 3;<br /> &nbsp;&nbsp;&nbsp; int y = 1;<br /> &nbsp;&nbsp;&nbsp; if (x = y)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Not equal");<br /> &nbsp;&nbsp; else<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Equal");<br /> &nbsp; }<br /> }<br /><br /> <strong>What is the result?</strong><br /> The output is &ldquo;Equal&rdquo;<br /> B. The output in &ldquo;Not Equal&rdquo;<br /> C. An error at " if (x = y)" causes compilation to fall.<br /> D. The program executes but no output is show on console.<br /> Answer: C<br /> Answer: Transient variable can't be serialize. For example if a variable is declared as transient in a Serializable class and the class is written to an ObjectStream, the value of the variable can't be written to the stream instead when the class is retrieved from the ObjectStream the value of the variable becomes null.<br /> <br /> # Question: Name the containers which uses Border Layout as their default layout?<br /> Answer: Containers which uses Border Layout as their default are: window, Frame and Dialog classes.<br /> <br /> # Question: What do you understand by Synchronization?<br /> Answer: Synchronization is a process of controlling the access of shared resources by the multiple threads in such a manner that only one thread can access one resource at a time. In non synchronized multithreaded application, it is possible for one thread to modify a shared object while another thread is in the process of using or updating the object's value. Synchronization prevents such type of data corruption.<br /> E.g. Synchronizing a function:<br /> public synchronized void Method1 () {<br /> // Appropriate method-related code. <br /> }<br /> E.g. Synchronizing a block of code inside a function:<br /> public myFunction (){<br /> synchronized (this) { <br /> // Synchronized code here.<br /> }<br /> }</p>
